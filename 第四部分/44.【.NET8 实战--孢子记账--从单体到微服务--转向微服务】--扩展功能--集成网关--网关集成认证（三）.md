这篇文章我们讲解《网关令牌内省服务》，涉及到网关令牌内省服务、OpenIddict验证扩展、认证中间件内容，我们现在开始吧。

### 一、网关令牌内省服务
令牌内省服务已经在前面的文章介绍过了，忘记的同学可以回顾一下《网关集成认证（一）》的内容。在网关中创建**令牌内省服务接口**，并实现该接口。令牌内省服务的作用是验证令牌的有效性，并返回令牌的相关信息，我们来看一下接口如何定义：
```csharp
using SP.Gateway.Models;

namespace SP.Gateway.Services;

/// <summary>
/// 令牌内省服务接口
/// </summary>
public interface ITokenIntrospectionService
{
    /// <summary>
    /// 验证令牌
    /// </summary>
    /// <param name="token">访问令牌</param>
    /// <param name="identityServiceUrl">身份服务URL</param>
    /// <returns>令牌信息</returns>
    Task<TokenIntrospectionResponse?> IntrospectTokenAsync(string token, string identityServiceUrl);
}
```
在这个接口中，我们只定义了一个方法`IntrospectTokenAsync`，它接受一个访问令牌和身份服务的URL，并返回一个`TokenIntrospectionResponse`对象，表示令牌的相关信息。以下是`TokenIntrospectionResponse`的定义：
```csharp
/// <summary>
/// 表示令牌内省（Token Introspection）接口的响应结果。
/// </summary>
public class TokenIntrospectionResponse
{
    /// <summary>
    /// 令牌是否处于激活状态。
    /// </summary>
    public bool IsActive { get; set; }

    /// <summary>
    /// 令牌关联的主体（Subject）。
    /// </summary>
    public string? Subject { get; set; }

    /// <summary>
    /// 令牌关联的用户名。
    /// </summary>
    public string? Username { get; set; }

    /// <summary>
    /// 令牌关联的邮箱地址。
    /// </summary>
    public string? Email { get; set; }

    /// <summary>
    /// 令牌的作用域（Scope）。
    /// </summary>
    public string? Scope { get; set; }

    /// <summary>
    /// 客户端标识（ClientId）。
    /// </summary>
    public string? ClientId { get; set; }

    /// <summary>
    /// 令牌过期时间（Unix时间戳，秒）。
    /// </summary>
    public long? ExpiresAt { get; set; }

    /// <summary>
    /// 令牌关联的角色列表。
    /// </summary>
    public List<string> Roles { get; set; } = new();

    /// <summary>
    /// 令牌关联的权限列表。
    /// </summary>
    public List<string> Permissions { get; set; } = new();
}
```
在这个类中，我们定义了多个属性来表示令牌的相关信息，包括是否激活、主体、用户名、邮箱、作用域、客户端标识、过期时间、角色和权限列表。接下来，我们需要实现这个接口，创建一个`TokenIntrospectionService`类来处理令牌内省的逻辑。

```csharp
using System.Text;
using System.Text.Json;
using SP.Gateway.Models;

namespace SP.Gateway.Services.Impl;

/// <summary>
/// 令牌内省服务实现
/// </summary>
public class TokenIntrospectionService : ITokenIntrospectionService
{
    // HttpClient 用于发送 HTTP 请求
    private readonly HttpClient _httpClient;

    // 日志记录器
    private readonly ILogger<TokenIntrospectionService> _logger;

    // 网关配置服务
    private readonly IGatewayConfigService _configService;

    /// <summary>
    /// 构造函数，注入依赖
    /// </summary>
    /// <param name="httpClient">HTTP 客户端</param>
    /// <param name="logger">日志记录器</param>
    /// <param name="configService">网关配置服务</param>
    public TokenIntrospectionService(
        HttpClient httpClient,
        ILogger<TokenIntrospectionService> logger,
        IGatewayConfigService configService)
    {
        _httpClient = httpClient;
        _logger = logger;
        _configService = configService;
    }

    /// <summary>
    /// 异步令牌内省方法，校验令牌有效性并解析相关信息
    /// </summary>
    /// <param name="token">待校验的令牌</param>
    /// <param name="identityServiceUrl">身份服务地址</param>
    /// <returns>令牌内省结果，若无效则返回 null</returns>
    public async Task<TokenIntrospectionResponse?> IntrospectTokenAsync(string token, string identityServiceUrl)
    {
        try
        {
            // 获取身份服务配置
            var config = await _configService.GetIdentityServiceConfigAsync();

            // 构造内省接口地址
            var introspectionUrl = $"{identityServiceUrl.TrimEnd('/')}/api/auth/introspect";
            // 构造请求体
            var requestData = new FormUrlEncodedContent(new[]
            {
                new KeyValuePair<string, string>("token", token)
            });

            // 若配置了客户端凭证，则添加 Basic Auth 头
            if (!string.IsNullOrEmpty(config.ClientId) && !string.IsNullOrEmpty(config.ClientSecret))
            {
                var authHeader = Convert.ToBase64String(
                    Encoding.UTF8.GetBytes($"{config.ClientId}:{config.ClientSecret}"));
                _httpClient.DefaultRequestHeaders.Authorization =
                    new System.Net.Http.Headers.AuthenticationHeaderValue("Basic", authHeader);
            }

            // 发送 POST 请求
            var response = await _httpClient.PostAsync(introspectionUrl, requestData);

            // 请求失败则记录警告并返回 null
            if (!response.IsSuccessStatusCode)
            {
                _logger.LogWarning("令牌内省请求失败，状态码: {StatusCode}", response.StatusCode);
                return null;
            }

            // 读取响应内容
            var content = await response.Content.ReadAsStringAsync();
            var introspectionResponse = JsonSerializer.Deserialize<JsonElement>(content);

            // 检查令牌是否有效
            if (!introspectionResponse.TryGetProperty("active", out var activeProperty) ||
                !activeProperty.GetBoolean())
            {
                _logger.LogDebug("令牌内省结果显示令牌无效");
                return null;
            }

            // 构造令牌内省结果对象
            var result = new TokenIntrospectionResponse
            {
                IsActive = true,
                Subject = GetStringProperty(introspectionResponse, "sub"),
                Username = GetStringProperty(introspectionResponse, "username"),
                Email = GetStringProperty(introspectionResponse, "email"),
                Scope = GetStringProperty(introspectionResponse, "scope"),
                ClientId = GetStringProperty(introspectionResponse, "client_id"),
                ExpiresAt = GetLongProperty(introspectionResponse, "exp")
            };

            // 解析角色信息
            if (introspectionResponse.TryGetProperty("roles", out var rolesProperty))
            {
                result.Roles = rolesProperty.EnumerateArray()
                    .Select(r => r.GetString())
                    .Where(r => !string.IsNullOrEmpty(r))
                    .ToList()!;
            }

            // 解析权限信息
            if (introspectionResponse.TryGetProperty("permissions", out var permissionsProperty))
            {
                result.Permissions = permissionsProperty.EnumerateArray()
                    .Select(p => p.GetString())
                    .Where(p => !string.IsNullOrEmpty(p))
                    .ToList()!;
            }

            _logger.LogDebug("令牌内省成功，用户: {Username}, 客户端: {ClientId}",
                result.Username, result.ClientId);

            return result;
        }
        catch (Exception ex)
        {
            // 异常处理，记录错误日志
            _logger.LogError(ex, "令牌内省时发生错误");
            return null;
        }
    }

    /// <summary>
    /// 从 JsonElement 获取字符串属性
    /// </summary>
    /// <param name="element">JsonElement 对象</param>
    /// <param name="propertyName">属性名</param>
    /// <returns>属性值或 null</returns>
    private static string? GetStringProperty(JsonElement element, string propertyName)
    {
        return element.TryGetProperty(propertyName, out var property) ? property.GetString() : null;
    }

    /// <summary>
    /// 从 JsonElement 获取长整型属性
    /// </summary>
    /// <param name="element">JsonElement 对象</param>
    /// <param name="propertyName">属性名</param>
    /// <returns>属性值或 null</returns>
    private static long? GetLongProperty(JsonElement element, string propertyName)
    {
        return element.TryGetProperty(propertyName, out var property) ? property.GetInt64() : null;
    }
}
```
这个实现代码整体围绕令牌内省（Token Introspection）流程展开，目的是在网关层对接收到的令牌进行有效性校验，并解析出令牌所包含的用户信息和权限数据。首先，在类的构造函数中，通过依赖注入获取了 `HttpClient`、日志记录器（Logger）以及网关配置服务（GatewayConfigService）。`HttpClient` 用于后续向身份认证服务发送 HTTP 请求，日志记录器负责在各个关键步骤输出日志，便于问题追踪和运维，而网关配置服务则提供了身份服务的相关配置参数，比如令牌内省接口地址、客户端标识（ClientId）、客户端密钥（ClientSecret）等。

在 `IntrospectTokenAsync` 方法中，首先通过配置服务获取身份服务的客户端标识和密钥，这些信息通常用于接口认证。随后，拼接出令牌内省接口的完整地址，并构造请求体，将待校验的令牌作为参数传递。此处请求体一般采用 `application/x-www-form-urlencoded` 格式，确保兼容 OAuth2 标准。如果身份服务配置了客户端凭证，则会将其按照 Basic Auth 的规范进行编码，并添加到 HTTP 请求头部，确保请求具备必要的认证信息，防止未授权访问令牌内省接口。

接下来，使用 `HttpClient` 以异步方式发送 POST 请求到令牌内省接口。收到响应后，首先检查 HTTP 状态码，如果请求失败（如 401、403 或 500），则通过日志记录器输出警告日志，并返回 null，表示令牌校验失败。若请求成功，则读取响应内容，并将其反序列化为 `JsonElement`，以便后续解析。此时会重点检查响应中的 `active` 字段，判断令牌是否处于激活状态。如果令牌无效或已过期，则记录调试日志并返回 null，避免后续流程继续处理无效令牌。

如果令牌有效，则从响应中依次提取主体（sub）、用户名（username）、邮箱（email）、作用域（scope）、客户端标识（client_id）、过期时间（exp）等关键信息，并赋值给 `TokenIntrospectionResponse` 对象。对于角色（roles）和权限（permissions）等列表字段，通常会进行解析和转换，确保能够正确存储到响应对象的对应属性中。整个过程中，日志记录器会在令牌内省成功时输出调试日志，方便后续追踪和分析。

该实现充分利用了依赖注入机制，使得各个服务之间解耦，便于测试和维护。同时采用异步编程模式，提高了接口调用的性能和响应速度。日志机制贯穿始终，确保在出现异常或关键事件时能够及时记录和定位问题。通过这种方式，令牌内省流程不仅安全可靠，还为后续的认证和授权逻辑提供了详实的用户和权限数据基础，极大提升了网关的安全性和可扩展性。

通过以上代码，我们实现了一个完整的网关令牌内省服务，可以在网关中使用它来验证令牌的有效性，并获取相关的用户信息和权限数据。

### 二、OpenIddict验证扩展
接下来，我们要实现OpenIddict验证扩展，以便在网关中使用OpenIddict进行令牌验证。我们需要创建一个`OpenIddictValidationExtensions`类，并在其中实现令牌验证的逻辑，我们来详细讲解一下代码。
```csharp
using OpenIddict.Validation.AspNetCore;
using SP.Gateway.Services;
using SP.Gateway.Services.Impl;

namespace SP.Gateway.Extension;

/// <summary>
/// OpenIddict验证扩展
/// </summary>
public static class OpenIddictValidationExtensions
{
    /// <summary>
    /// 添加OpenIddict验证服务
    /// </summary>
    /// <param name="services"></param>
    /// <param name="configuration"></param>
    /// <returns></returns>
    public static IServiceCollection AddOpenIddictValidation(this IServiceCollection services,
        IConfiguration configuration)
    {
        services.AddSingleton<INacosServiceDiscoveryService, NacosServiceDiscoveryService>();
        services.AddSingleton<IGatewayConfigService, NacosGatewayConfigService>();
        services.AddScoped<ITokenIntrospectionService, TokenIntrospectionService>();

        services.AddHttpClient("IdentityServiceHealthCheck", client => { client.Timeout = TimeSpan.FromSeconds(10); });

        services.AddHttpClient("TokenIntrospection", client => { client.Timeout = TimeSpan.FromSeconds(30); });

        services.AddOpenIddict()
            .AddValidation(options =>
            {
                // 获取动态Issuer URL
                var discoveryService =
                    services.BuildServiceProvider().GetRequiredService<INacosServiceDiscoveryService>();
                var issuerUrl = discoveryService.GetBestIdentityServiceUrlAsync().Result;
                if (string.IsNullOrEmpty(issuerUrl))
                {
                    throw new Exception("No healthy IdentityService instances found in Nacos.");
                }

                // 从配置服务获取客户端凭证
                var configService = services.BuildServiceProvider().GetRequiredService<IGatewayConfigService>();
                var config = configService.GetIdentityServiceConfigAsync().Result;

                // 使用内省（introspection）进行远程验证
                options.UseIntrospection()
                    .SetIssuer(new Uri(issuerUrl))
                    .SetClientId(config.ClientId)
                    .SetClientSecret(config.ClientSecret);

                // 启用ASP.NET Core集成
                options.UseAspNetCore();

                // 配置令牌验证参数
                options.Configure(options =>
                {
                    options.TokenValidationParameters.ValidateIssuer = true;
                    options.TokenValidationParameters.ValidAudience = "api"; // 设置受众
                    options.TokenValidationParameters.ValidateAudience = true;
                    options.TokenValidationParameters.ValidateLifetime = true;
                    options.TokenValidationParameters.ValidateIssuerSigningKey = true;
                });
            });

        services.AddAuthentication(OpenIddictValidationAspNetCoreDefaults.AuthenticationScheme);
        services.AddAuthorization();

        return services;
    }
}
```
通过上述扩展方法，网关项目能够灵活地集成 OpenIddict 验证机制，实现对分布式身份认证服务的动态发现和远程令牌校验。服务注册部分采用依赖注入模式，将服务发现、网关配置和令牌内省等关键组件统一管理，提升了系统的可维护性和扩展性。动态获取健康的身份服务地址和客户端凭证，确保令牌校验请求始终具备最新的认证信息，有效应对微服务环境下的服务变更和故障切换。配置多个带超时的 `HttpClient` 实例，增强了接口调用的稳定性和容错能力，避免因网络异常导致认证流程阻塞。核心验证流程通过 OpenIddict 的 introspection 机制，将令牌校验逻辑委托给远程身份服务，实时判断令牌的有效性和权限信息，适用于高并发和多租户场景。启用 ASP.NET Core 集成后，认证中间件能够自动识别并处理 HTTP 请求中的 Bearer Token，结合严格的验证参数（如 Issuer、Audience、过期时间和签名密钥）进行安全校验，防止伪造和滥用令牌。设置默认认证方案和授权策略后，开发者只需在控制器或接口上添加 [Authorize] 特性，即可实现对受保护资源的统一访问控制，无需关心底层认证细节。整体来看，这套扩展方案不仅提升了网关的安全性和灵活性，还为后续的权限管理和用户审计打下了坚实基础，是微服务架构下统一认证与授权的理想选择。

### 三、认证中间件
最后，我们需要在网关中添加认证中间件，以便在请求到达网关时进行令牌验证。认证中间件的核心作用是拦截所有进入网关的 HTTP 请求，根据配置判断是否需要认证，并对令牌进行有效性校验。
```csharp
using System.Security.Claims;
using Microsoft.AspNetCore.Authentication;
using OpenIddict.Abstractions;
using SP.Common.Redis;
using SP.Gateway.Services;


namespace SP.Gateway.Middleware;

/// <summary>
/// 完整的认证中间件
/// </summary>
public class AuthenticationMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<AuthenticationMiddleware> _logger;
    private readonly IRedisService _redisService;
    private readonly IGatewayConfigService _configService;
    private readonly INacosServiceDiscoveryService _serviceDiscovery;
    private readonly ITokenIntrospectionService _tokenIntrospectionService;

    public AuthenticationMiddleware(
        RequestDelegate next,
        ILogger<AuthenticationMiddleware> logger,
        IRedisService redisService,
        IGatewayConfigService configService,
        INacosServiceDiscoveryService serviceDiscovery,
        ITokenIntrospectionService tokenIntrospectionService)
    {
        _next = next;
        _logger = logger;
        _redisService = redisService;
        _configService = configService;
        _serviceDiscovery = serviceDiscovery;
        _tokenIntrospectionService = tokenIntrospectionService;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var path = context.Request.Path.Value ?? "";
        
        var requiresAuthentication = await _configService.IsAuthenticationRequiredAsync(path);
        
        if (!requiresAuthentication)
        {
            _logger.LogDebug("路径 {Path} 跳过认证", path);
            await _next(context);
            return;
        }

        try
        {
            var bestUrl = await _serviceDiscovery.GetBestIdentityServiceUrlAsync();
            
            if (string.IsNullOrEmpty(bestUrl))
            {
                context.Response.StatusCode = 503;
                await context.Response.WriteAsJsonAsync(new { 
                    error = "service_unavailable", 
                    error_description = "身份服务不可用" 
                });
                return;
            }

            context.Request.Headers["X-Identity-Service-Url"] = bestUrl;

            var result = await context.AuthenticateAsync();
            
            if (result?.Succeeded == true && result.Principal != null)
            {
                var userId = result.Principal.FindFirstValue(OpenIddictConstants.Claims.Subject);
                if (!string.IsNullOrEmpty(userId))
                {
                    var tokenExists = await ValidateTokenInRedis(userId, context.Request.Headers["Authorization"].ToString());
                    if (!tokenExists)
                    {
                        context.Response.StatusCode = 401;
                        await context.Response.WriteAsJsonAsync(new { 
                            error = "invalid_token", 
                            error_description = "令牌已被撤销" 
                        });
                        return;
                    }
                }

                context.User = result.Principal;
                
                var userInfo = ExtractUserInfo(result.Principal);
                foreach (var kvp in userInfo)
                {
                    context.Request.Headers[kvp.Key] = kvp.Value;
                }
                
                context.Request.Headers["X-Used-Identity-Service"] = bestUrl;
                
                await _next(context);
            }
            else
            {
                context.Response.StatusCode = 401;
                await context.Response.WriteAsJsonAsync(new { 
                    error = "invalid_token", 
                    error_description = "无效的访问令牌" 
                });
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "认证过程中发生错误");
            context.Response.StatusCode = 500;
            await context.Response.WriteAsJsonAsync(new { 
                error = "server_error", 
                error_description = "认证服务内部错误" 
            });
        }
    }

    private async Task<bool> ValidateTokenInRedis(string userId, string authorizationHeader)
    {
        try
        {
            if (string.IsNullOrEmpty(authorizationHeader) || !authorizationHeader.StartsWith("Bearer "))
            {
                return false;
            }

            var token = authorizationHeader.Substring("Bearer ".Length);
            
            var tokenKey = $"Token:{userId}";
            var storedToken = await _redisService.GetAsync<string>(tokenKey);
            
            if (string.IsNullOrEmpty(storedToken))
            {
                return true;
            }
            
            return storedToken == token;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "验证Redis中的令牌时发生错误");
            return false;
        }
    }

    private Dictionary<string, string> ExtractUserInfo(ClaimsPrincipal principal)
    {
        var userInfo = new Dictionary<string, string>();
        
        var userId = principal.FindFirstValue(OpenIddictConstants.Claims.Subject);
        var username = principal.FindFirstValue(OpenIddictConstants.Claims.Name);
        var email = principal.FindFirstValue(OpenIddictConstants.Claims.Email);
        var roles = principal.FindAll(OpenIddictConstants.Claims.Role).Select(c => c.Value);
        
        if (!string.IsNullOrEmpty(userId))
            userInfo["X-User-Id"] = userId;
        if (!string.IsNullOrEmpty(username))
            userInfo["X-User-Name"] = username;
        if (!string.IsNullOrEmpty(email))
            userInfo["X-User-Email"] = email;
        if (roles.Any())
            userInfo["X-User-Roles"] = string.Join(",", roles);
            
        return userInfo;
    }
}
```

这段中间件的逻辑是一个完整的认证流程描述。当请求进入时，首先会读取请求路径，并通过配置服务判断该路径是否需要认证，如果不需要则直接跳过继续执行后续中间件。若需要认证，则先通过服务发现获取一个可用的身份服务地址，如果没有获取到，则返回 503，提示身份服务不可用。成功获取后，会把该地址写入请求头，供后续使用。接下来调用框架内置的 `AuthenticateAsync` 执行 OpenIddict 的令牌验证。如果验证成功并且能解析出用户主体，则会取出用户 ID，再结合请求头里的访问令牌去 Redis 做一次二次校验：检查 Redis 中是否存有该用户的令牌记录，如果存有但与当前令牌不一致，说明令牌已被撤销，则返回 401；如果一致或 Redis 没存该用户令牌，则视为合法继续处理。校验通过后，会将认证得到的 `ClaimsPrincipal` 赋给当前上下文用户，并从中提取用户 ID、用户名、邮箱和角色等信息写入请求头，方便后续服务消费，同时也记录下使用的身份服务地址，最后进入后续中间件。若 `AuthenticateAsync` 验证失败，则直接返回 401 并提示无效令牌。如果认证过程中发生异常，则记录日志并返回 500，提示服务器内部错误。整体上，这个中间件实现了“路径级别认证控制 → 动态身份服务发现 → 框架内验证令牌 → Redis 校验令牌有效性 → 将用户信息透传给下游服务”的完整认证闭环。

在所有工作完成后，我们需要在网关的`Program.cs` 中注册这个认证中间件，以便在请求管道中使用它，代码如下：
```csharp
// more code ...

// 添加OpenIddict验证服务（基于Nacos服务发现和配置）
builder.Services.AddOpenIddictValidation(builder.Configuration);

// more code ...

// 添加完整认证中间件
app.UseMiddleware<SPAuthenticationMiddleware>();

// more code ...

```
这样，我们就完成了认证中间件的注册。通过这个中间件，我们可以在网关中对请求进行令牌验证，并将用户信息传递给下游服务。

### 四、总结
在这篇文章中，我们介绍了如何在网关中实现令牌内省服务、OpenIddict验证扩展和认证中间件。通过这些组件，我们可以在网关层对令牌进行有效性验证，并将用户信息传递给下游服务。这种设计不仅提高了系统的安全性，还增强了微服务架构的灵活性和可扩展性。
希望这篇文章对你理解网关令牌内省服务有所帮助。如果你有任何问题或建议，请随时在评论区留言。感谢你的阅读，我们下次再见！