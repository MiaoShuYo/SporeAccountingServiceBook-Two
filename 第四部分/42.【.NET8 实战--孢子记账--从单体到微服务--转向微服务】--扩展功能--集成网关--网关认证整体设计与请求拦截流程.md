我们将在本文中对网关服务的认证功能进行设计与实现。我们会从设计目标、核心组件、管道接入到令牌内省与失败兜底说明实现思路，并展示关键的代码片段，完整的实现代码大家可以在专栏配套的[GitHub源代码](https://github.com/MiaoShuYo/SporeAccounting)中查看。


### 一、设计目标与范围
我们的网关就像一个门卫,它会在请求到达后面的微服务之前先把关。它可以根据不同的路径灵活地决定要不要检查通行证(也就是NoAuthPaths)。检查通行证的时候,网关不会自己去研究通行证的细节,而是问专门负责身份验证的服务"这个通行证是不是有效"。这样做的好处是,以后要改变验证方式的话会更方便。

网关还跟服务发现系统打得火热,当有多个身份验证服务在运行时,它能挑选一个状态良好的来用。而且为了让系统更稳定,我们还给网关配了"超时报警"、"重试机制"和"应急预案"这些保障措施。下面这段代码就展示了我们是怎么把这些功能在网关的`Program`类中进行组合的：

```csharp
builder.Services.AddSingleton<INacosServiceDiscoveryService, NacosServiceDiscoveryService>();
builder.Services.AddSingleton<IGatewayConfigService, NacosGatewayConfigService>();
builder.Services.AddScoped<ITokenIntrospectionService, TokenIntrospectionService>();
```

### 二、核心功能开发
###### 2.1 初始化 SPAuthenticationMiddleware 中间件
认证相关的网关组件围绕 **“中间件 + 配置 + 服务发现 + 令牌内省”** 构建。中间件是统一拦截入口，配置服务负责动态放行与身份服务参数，服务发现负责挑选可用身份服务，令牌内省负责与身份服务对话解析令牌。下面的中间件定义展示了网关侧的中间件`SPAuthenticationMiddleware`如何聚合这些职责：

```csharp
public class SPAuthenticationMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<SPAuthenticationMiddleware> _logger;
    private readonly IRedisService _redisService;
    private readonly IGatewayConfigService _configService;
    private readonly INacosServiceDiscoveryService _serviceDiscovery;
    private readonly ITokenIntrospectionService _tokenIntrospectionService;
    private readonly IConfiguration _configuration;

    public SPAuthenticationMiddleware(
        RequestDelegate next,
        ILogger<SPAuthenticationMiddleware> logger,
        IRedisService redisService,
        IGatewayConfigService configService,
        INacosServiceDiscoveryService serviceDiscovery,
        ITokenIntrospectionService tokenIntrospectionService,
        IConfiguration configuration) 
        {
            // more code ...
        }
}
```

在上面的代码中，我们可以看到`SPAuthenticationMiddleware`的构造函数接收了多个参数，这些参数都是网关认证功能的核心组件。这些组件的职责如下：
- `RequestDelegate next`：用于将请求传递给下一个中间件。
- `ILogger<SPAuthenticationMiddleware> logger`：用于记录日志。
- `IRedisService redisService`：用于操作 Redis 缓存。
- `IGatewayConfigService configService`：用于获取网关配置。
- `INacosServiceDiscoveryService serviceDiscovery`：用于发现身份服务。
- `ITokenIntrospectionService tokenIntrospectionService`：用于内省令牌。
- `IConfiguration configuration`：用于获取应用程序配置。

###### 2.2 中间件接入点与执行顺序
认证中间件需要在 Ocelot 之前执行，以保证未经认证的流量无法进入下游路由匹配。这是因为 Ocelot 作为网关的核心路由组件，一旦请求进入其处理流程，就意味着已经开始进行下游服务的匹配和转发。如果在这之后才进行认证，可能会导致未授权的请求已经消耗了系统资源，甚至可能泄露一些敏感的路由信息。我们在网关的`Program`类中配置认证中间件如下：

```csharp
// more code ...
app.UseHttpsRedirection();
app.UseMiddleware<SPAuthenticationMiddleware>();
app.MapControllers();
await app.UseOcelot();
// more code ...
```

上述顺序确保了请求先经过认证门禁，再进入控制器与 Ocelot 的下游转发逻辑，文档聚合（SwaggerForOcelot）也能被保护。

###### 2.3 请求拦截与认证流程
请求进入中间件后会启动一个完整的认证流程。中间件`SPAuthenticationMiddleware`首先会通过配置服务`IGatewayConfigService`获取当前请求路径是否需要进行认证校验，这个判断过程会检查请求路径是否匹配预设的免认证路径列表。对于需要认证的路径，中间件会从请求头中提取Authorization信息，要求必须是Bearer类型的令牌。在获取到令牌后，中间件会通过服务发现组件`INacosServiceDiscoveryService`来选择一个最佳的身份认证服务实例，这个选择过程会考虑服务的健康状态和当前负载情况。接着，中间件使用`ITokenIntrospectionService`向选定的身份服务发送令牌内省请求，进行令牌验证并获取令牌中包含的用户信息。当令牌验证通过后，中间件会构建一个包含用户身份信息的ClaimsPrincipal对象，将其设置到`HttpContext.User`中，同时添加网关签名等特殊请求头，最后将请求传递给下一个中间件继续处理。在这个过程中，如果发生令牌缺失、格式错误、身份服务不可用或令牌验证失败等异常情况，中间件会返回相应的HTTP状态码和标准化的错误响应。核心流程代码如下：

```csharp
// SPAuthenticationMiddleware.cs 认证流程代码
public async Task InvokeAsync(HttpContext context)
{
    var path = context.Request.Path.Value ?? string.Empty;
    var isAuth = await _configService.IsAuthenticationRequiredAsync(path);
    if (!isAuth)
    {
        _logger.LogDebug("路径 {Path} 跳过认证", path);
        context.Request.Headers["X-Anonymous"] = "true";
        context.Request.Headers["X-Gateway-Signature"] = GenerateGatewaySignature();
        await _next(context);
        return;
    }

    var authorizationHeader = context.Request.Headers["Authorization"].ToString();
    if (string.IsNullOrEmpty(authorizationHeader) || !authorizationHeader.StartsWith("Bearer "))
    {
        context.Response.StatusCode = 401;
        await context.Response.WriteAsJsonAsync(new { error = "invalid_token", error_description = "缺少有效的访问令牌" });
        return;
    }

    var token = authorizationHeader.Substring("Bearer ".Length);
    var bestUrl = await _serviceDiscovery.GetBestIdentityServiceUrlAsync();
    if (string.IsNullOrEmpty(bestUrl))
    {
        context.Response.StatusCode = 503;
        await context.Response.WriteAsJsonAsync(new { error = "service_unavailable", error_description = "身份服务不可用" });
        return;
    }

    var introspectionResult = await _tokenIntrospectionService.IntrospectTokenAsync(token, bestUrl);
    if (introspectionResult == null || !introspectionResult.IsActive)
    {
        context.Response.StatusCode = 401;
        await context.Response.WriteAsJsonAsync(new { error = "invalid_token", error_description = "无效的访问令牌" });
        return;
    }

    var claims = new List<Claim>
    {
        new(OpenIddictConstants.Claims.Subject, introspectionResult.Subject ?? string.Empty),
        new(OpenIddictConstants.Claims.Name, introspectionResult.Username ?? string.Empty),
        new(OpenIddictConstants.Claims.Email, introspectionResult.Email ?? string.Empty)
    };
    if (introspectionResult.Roles != null)
    {
        foreach (var role in introspectionResult.Roles)
            claims.Add(new Claim(OpenIddictConstants.Claims.Role, role));
    }
    context.User = new ClaimsPrincipal(new ClaimsIdentity(claims, "Bearer"));
    context.Request.Headers["X-Used-Identity-Service"] = bestUrl;
    context.Request.Headers["X-Gateway-Signature"] = GenerateGatewaySignature();
    await _next(context);
}
```
通过上述代码实现,我们完成了网关认证中间件的核心流程。该中间件能够根据请求路径判断认证需求,从请求头中提取并验证Bearer令牌,通过服务发现选择可用的身份认证服务,调用令牌内省接口验证令牌有效性,解析用户身份信息并构建Claims,同时添加网关签名等特殊请求头。

###### 2.4 路径豁免策略（NoAuthPaths）
路径放行机制是由配置服务来统一管理的。配置服务会从配置中心读取预设的免认证路径列表(NoAuthPaths)，并将其缓存在内存中。当请求进入网关时，配置服务会根据当前请求的路径与这些预设路径进行匹配，判断是否需要进行认证校验。匹配规则支持前缀匹配和包含匹配两种方式，这样可以灵活地适应不同的路由配置风格。例如，如果配置了"/api/public/"作为免认证路径，那么所有以此开头的请求都将被自动放行。对于那些没有匹配到任何免认证规则的请求路径，系统会要求其必须携带有效的身份认证令牌。这种设计既保证了系统的安全性，又为某些特定场景（如健康检查、公开API等）提供了便利的访问通道。配置服务还会定期从配置中心刷新这些规则，确保路径放行策略能够动态更新，而无需重启网关服务。以下代码是`NacosGatewayConfigService`类中路径豁免策略的代码：

```csharp
// NacosGatewayConfigService.cs 路径豁免策略代码
public async Task<List<string>> GetSkipAuthenticationPathsAsync()
{
    var configValue = _configuration.GetSection("NoAuthPaths").Get<List<string>>();
    return configValue ?? new List<string>();
}

public async Task<bool> IsAuthenticationRequiredAsync(string path)
{
    var skipPaths = await GetSkipAuthenticationPathsAsync();
    if (skipPaths.Any(p => path.StartsWith(p, StringComparison.OrdinalIgnoreCase)) ||
        skipPaths.Any(p => path.Contains(p, StringComparison.OrdinalIgnoreCase)))
    {
        return false; // 命中放行
    }
    return true; // 默认需要认证
}
```
上述判定既支持前缀匹配也支持包含匹配，便于兼容不同风格的路由配置；同时配合中间件中的 X-Anonymous 与网关签名头，确保放行流量具备可追踪特征。

###### 2.5 与身份服务的令牌内省交互
令牌内省是网关与身份服务之间进行令牌有效性验证的关键环节。在`TokenIntrospectionService`类中，我们通过专用的`HttpClient`向身份服务发送令牌内省请求。这个请求使用`application/x-www-form-urlencoded`格式，将待验证的令牌作为表单数据发送。

服务会解析响应中的关键字段，包括表示令牌是否有效的`active`字段、令牌所属用户标识的`sub`字段、用户拥有的角色列表`roles`字段、用户名`username`字段以及用户邮箱`email`字段。为了确保通信安全性，请求会携带网关签名等特殊头部。当遇到网络异常、服务不可用或令牌无效等情况时，服务会返回空结果，由上层中间件进行统一的错误处理。主要核心代码如下：

```csharp
// TokenIntrospectionService.cs 与身份服务的令牌内省交互部分的代码
public async Task<TokenIntrospectionResponse?> IntrospectTokenAsync(string token, string identityServiceUrl)
{
    var introspectionUrl = $"{identityServiceUrl.TrimEnd('/')}/api/auth/introspect";
    var request = new HttpRequestMessage(HttpMethod.Post, introspectionUrl)
    {
        Content = new FormUrlEncodedContent(new[] { new KeyValuePair<string, string>("token", token) })
    };
    request.Content.Headers.ContentType =
        new System.Net.Http.Headers.MediaTypeHeaderValue("application/x-www-form-urlencoded");
    request.Headers.Add("X-Anonymous", "true");
    request.Headers.Add("X-Gateway-Signature", GenerateGatewaySignature());

    var response = await _httpClient.SendAsync(request);
    if (!response.IsSuccessStatusCode) return null;

    var content = await response.Content.ReadAsStringAsync();
    var json = JsonSerializer.Deserialize<JsonElement>(content);
    if (!json.TryGetProperty("active", out var active) || !active.GetBoolean()) return null;

    var result = new TokenIntrospectionResponse
    {
        IsActive = true,
        Subject = json.TryGetProperty("sub", out var sub) ? sub.GetString() : null,
        Username = json.TryGetProperty("username", out var name) ? name.GetString() : null,
        Email = json.TryGetProperty("email", out var mail) ? mail.GetString() : null
    };
    if (json.TryGetProperty("roles", out var roles))
        result.Roles = roles.EnumerateArray().Select(r => r.GetString()!).Where(s => !string.IsNullOrEmpty(s)).ToList();
    return result;
}
```
上述代码实现了令牌内省服务的核心功能。它通过HTTP请求与身份服务进行交互，发送令牌进行验证，并解析返回的用户信息。这个服务支持错误处理、请求签名和响应解析，确保了网关认证流程的安全性和可靠性。

###### 2.6 失败处理与返回格式
在网关认证过程中，错误处理是一个关键环节。中间件采用了统一的错误返回机制，通过明确的 HTTP 状态码与标准化的 JSON 响应体来处理各类认证失败场景。当请求缺少令牌或令牌格式不符合 Bearer 规范时，中间件会返回 401 Unauthorized 状态码，并在响应体中包含 error 与 error_description 字段，清晰地说明认证失败的具体原因。对于身份服务不可用等基础设施异常情况，中间件会返回 503 Service Unavailable 状态码，同样附带详细的错误描述。这种标准化的错误返回格式不仅方便前端应用统一处理认证相关的异常情况，也便于通过网关日志快速定位和分析认证失败的具体原因。以下代码是`SPAuthenticationMiddleware`中间件中的失败处理与返回格式代码：

```csharp
// SPAuthenticationMiddleware.cs 失败处理与返回格式部分的代码
if (string.IsNullOrEmpty(authorizationHeader) || !authorizationHeader.StartsWith("Bearer "))
{
    context.Response.StatusCode = 401;
    await context.Response.WriteAsJsonAsync(new { error = "invalid_token", error_description = "缺少有效的访问令牌" });
    return;
}

if (string.IsNullOrEmpty(bestUrl))
{
    context.Response.StatusCode = 503;
    await context.Response.WriteAsJsonAsync(new { error = "service_unavailable", error_description = "身份服务不可用" });
    return;
}
```

###### 2.7 安全与健壮性考量
在网关与身份服务的交互过程中，安全性和系统稳定性是重中之重。为了防止令牌在传输过程中被恶意第三方截获并重放或篡改，我们在网关中实现了基于时间戳的签名机制。每个请求都会携带一个由当前 UTC 时间戳和网关密钥组合生成的签名，这个签名被编码为 Base64 格式并通过请求头传递。网关密钥通过配置系统集中管理，便于在安全需求变化时快速更新。当发生异常情况时，如 Redis 连接中断导致缓存校验失败，或者令牌内省请求超时、网络异常等，系统会自动进入降级模式，同时通过结构化日志详细记录异常信息，包括请求路径、时间戳、错误类型等关键数据。这些日志不仅用于问题诊断，还可以作为安全审计的依据。通过这种多层次的保护机制，我们在保证系统可用性的同时，也为安全防护提供了可靠的基础设施支持：

```csharp
// SPAuthenticationMiddleware.cs 中的安全与健壮性代码
private string GenerateGatewaySignature()
{
    var timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
    var secret = _configuration["GatewaySecret"] ?? "SP_Gateway_Secret_2024";
    var signature = $"{timestamp}.{secret}";
    return Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(signature));
}
```

###### 2.8 与 Ocelot 的协作关系
在整个网关认证流程中，Ocelot 扮演着核心的路由与聚合角色。它被有意地安排在认证中间件之后执行，这样可以确保所有到达 Ocelot 的请求都已经过了身份验证的把关。在服务注册环节，我们通过启用 Nacos 的服务发现能力来增强 Ocelot 的动态性。这种集成让 Ocelot 能够实时感知下游服务的变化，从而实现更灵活的路由分发。同时，Ocelot 还负责聚合各个微服务的 Swagger 文档，为开发团队提供统一的 API 文档视图。这种设计不仅保证了访问安全，还可以通过服务发现提供了良好的扩展性，使得整个网关层既能保护下游服务，又能灵活应对服务的动态变化。

```csharp
// Program.cs 中 Ocelot 配置与服务注册部分的代码
builder.Services.AddOcelot(builder.Configuration).AddNacosDiscovery();

if (builder.Environment.IsDevelopment() || builder.Environment.EnvironmentName == "Local")
{
    builder.Services.AddSwaggerGen();
    builder.Services.AddSwaggerForOcelot(builder.Configuration);
}
```

### 三、总结
这篇文章详细讲解了包括网关认证、Ocelot 路由与聚合、服务注册与发现、Swagger 文档集成等。通过这些组件的协同工作，我们构建了一个安全、稳定、可扩展的微服务平台。